/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 ./public/Elektrik_Ibanez.glb 
*/

import React, { useRef, useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import { UseCustomization } from "../context/ColorContext";
import { UseTexture } from "../context/TextureContext";
import { TextureLoader } from "three";

export function Elektrik_Ibanez(props) {
  const { nodes } = useGLTF("/Elektrik_Ibanez.glb");
  const ColorContext = UseCustomization();
  const { Tuner, Neck, Nut, Fret, FretBoard, Body, Bridge, BridgeNut } =
    ColorContext;
  const bridgenut = useRef();
  const fret = useRef();
  const bridge = useRef();
  const nut = useRef();
  const body = useRef();
  const neck = useRef();
  const tuner = useRef();
  const fretboard = useRef();
  const materials = useRef();
  const {
    TunerTxt,
    FretTxt,
    FretBoardTxt,
    NeckTxt,
    NutTxt,
    BodyTxt,
    BridgeTxt,
    BridgeNutTxt,
  } = UseTexture();

  useEffect(() => {
    const loadTexture = async () => {
      if (TunerTxt) {
        try {
          const textureLoader = new TextureLoader();
          const texture = await textureLoader.loadAsync(TunerTxt);
          tuner.current.map = texture;
          tuner.current.needsUpdate = true;
        } catch (error) {}
      }
    };
    loadTexture();
  }, [TunerTxt]);

  useEffect(() => {
    const loadTexture = async () => {
      if (NeckTxt) {
        try {
          const textureLoader = new TextureLoader();
          const texture = await textureLoader.loadAsync(NeckTxt);
          neck.current.map = texture;
          neck.current.needsUpdate = true;
        } catch {}
      }
    };
    loadTexture();
  }, [NeckTxt]);

  useEffect(() => {
    const loadTexture = async () => {
      if (BodyTxt) {
        try {
          const textureLoader = new TextureLoader();
          const texture = await textureLoader.loadAsync(BodyTxt);
          body.current.map = texture;
          body.current.needsUpdate = true;
        } catch {}
      }
    };
    loadTexture();
  }, [BodyTxt]);

  useEffect(() => {
    const loadTexture = async () => {
      if (FretBoardTxt) {
        try {
          const textureLoader = new TextureLoader();
          const texture = await textureLoader.loadAsync(FretBoardTxt);
          fretboard.current.map = texture;
          fretboard.current.needsUpdate = true;
        } catch {}
      }
    };
    loadTexture();
  }, [FretBoardTxt]);

  useEffect(() => {
    const loadTexture = async () => {
      if (FretTxt) {
        try {
          const textureLoader = new TextureLoader();
          const texture = await textureLoader.loadAsync(FretTxt);
          fret.current.map = texture;
          fret.current.needsUpdate = true;
        } catch (error) {}
      }
    };
    loadTexture();
  }, [FretTxt]);

  useEffect(() => {
    const loadTexture = async () => {
      if (NutTxt) {
        try {
          const textureLoader = new TextureLoader();
          const texture = await textureLoader.loadAsync(NutTxt);
          nut.current.map = texture;
          nut.current.needsUpdate = true;
        } catch {}
      }
    };
    loadTexture();
  }, [NutTxt]);

  useEffect(() => {
    const loadTexture = async () => {
      if (BridgeNutTxt) {
        try {
          const textureLoader = new TextureLoader();
          const texture = await textureLoader.loadAsync(BridgeNutTxt);
          bridgenut.current.map = texture;
          bridgenut.current.needsUpdate = true;
        } catch {}
      }
    };
    loadTexture();
  }, [BridgeNutTxt]);

  useEffect(() => {
    const loadTexture = async () => {
      if (BridgeTxt) {
        try {
          const textureLoader = new TextureLoader();
          const texture = await textureLoader.loadAsync(BridgeTxt);
          bridge.current.map = texture;
          bridge.current.needsUpdate = true;
        } catch {}
      }
    };
    loadTexture();
  }, [BridgeTxt]);
  return (
    <group {...props} dispose={null}>
      <mesh
        geometry={nodes.SoundBoard.geometry}
        material={materials.SoundBoard}
        position={[0.158, -1.305, -0.55]}
        rotation={[Math.PI / 2, 0, 0]}
      >
        <meshStandardMaterial {...props} color={Bridge.color} ref={bridge} />
      </mesh>
      <mesh
        geometry={nodes.Neck.geometry}
        material={materials.Neck}
        position={[0.087, 0.143, 0.124]}
      >
        <meshStandardMaterial {...props} color={Neck.color} ref={neck} />
      </mesh>
      <mesh
        geometry={nodes.Body.geometry}
        material={materials.Body}
        position={[0.194, -1.285, 0.148]}
        rotation={[Math.PI / 2, 0, 0]}
      >
        <meshStandardMaterial {...props} color={Body.color} ref={body} />
      </mesh>
      <mesh
        geometry={nodes.Nut.geometry}
        material={materials.Nut}
        position={[0.08, 1.234, 0.21]}
      >
        <meshStandardMaterial {...props} color={Nut.color} ref={nut} />
      </mesh>
      <mesh
        geometry={nodes.BridgeNut.geometry}
        material={materials.BridgeNut}
        position={[0.009, -0.955, 0.161]}
        rotation={[Math.PI / 2, 0, 0]}
      >
        <meshStandardMaterial
          {...props}
          color={BridgeNut.color}
          ref={bridgenut}
        />
      </mesh>
      <mesh
        geometry={nodes.Bridge.geometry}
        material={materials.Bridge}
        position={[0.203, -1.698, 0.408]}
      >
        <meshStandardMaterial {...props} color={Bridge.color} ref={bridge} />
      </mesh>
      <mesh
        geometry={nodes.FretBoard.geometry}
        material={materials.FretBoard}
        position={[0.566, 0.51, -0.486]}
      >
        <meshStandardMaterial
          {...props}
          color={FretBoard.color}
          ref={fretboard}
        />
      </mesh>
      <mesh
        geometry={nodes.Fret.geometry}
        material={materials.Fret}
        position={[0.077, -0.835, 0.195]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[0.006, 0.119, 0.015]}
      >
        <meshStandardMaterial {...props} color={Fret.color} ref={fret} />
      </mesh>
      <mesh
        geometry={nodes.Tuner.geometry}
        material={materials.Tuner}
        position={[0.238, -1.611, 0.396]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.066, 0.036, 0.059]}
      >
        <meshStandardMaterial {...props} color={Tuner.color} ref={tuner} />
      </mesh>
    </group>
  );
}

export default Elektrik_Ibanez;
useGLTF.preload("/Elektrik_Ibanez.glb");
